<?php
/**
 * Skeleton subclass for representing a row from the 'wow_objets' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.6.4-dev on:
 *
 * 12/23/11 16:58:37
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    propel.generator.lib.model
 */
class Objet extends BaseObjet
{
    //---------------------------------------------------------------
    // gestion des loots
    //---------------------------------------------------------------

    /** liste des persos prioritaires */
    protected $listeAttributions = array();

    /**
     * construit la liste des personnages prioritaires à partir des
     * wishlists des personnages en paramètre
     * @param array $listePersos liste des personnages concernés
     */
    public function initPersosPrioritaires($listePersos)
    {
        // récup des persos à travers les wishlists pour cet objet
        $listePersosParId = nlMisc::indexBy('IdPerso', $listePersos);

        // liste des objets fils
        $listeIdObjetAChercher = SourceObjetQuery::create()
            ->join('Objet')
            ->select('Objet.IdObjet')
            ->filterByType('Objet')
            ->filterByIdType($this->getIdObjet())
            ->filterByCode('token')
            ->find()
            ->getData();

        if(empty($listeIdObjetAChercher))
            $listeIdObjetAChercher = array($this->getIdObjet());

        // cherche les éléments de wishlist possibles
        $listeWlObjets = WishlistObjetQuery::create()

            // qui contiennent cet objet ou ses enfants
            ->join('WishlistObjet.Objet')->with('Objet')
            ->filterByIdObjet($listeIdObjetAChercher)

            // sans être attribué définitivement si déja attribué
            ->join('Attribution', Criteria::LEFT_JOIN)
            ->condition('none', 'WishlistObjet.IdAttribution is null')
            ->condition('tmp', 'Attribution.Tmp = ?', 1)
            ->where(array('tmp','none'), 'or')

            // reliés à une wishlist
            ->useWishlistQuery()

                // appartenants aux persos courants
                ->join('Wishlist.Perso')->with('Perso')
                ->filterByIdPerso(array_keys($listePersosParId))

                // de type correspondant au type d'objet en cours
                ->useTypeWishlistQuery()
                    ->filterByCode($this->getHeroique() == 1
                        ? array('hm_sp1', 'hm_sp2')
                        : array('n_sp1', 'n_sp2')
                    )
                ->endUse()

            ->endUse()
            ->find();

        $this->listeAttributions = $listeWlObjets->getData();

        if(!usort($this->listeAttributions, array('Wishlist', 'trierObjet' )))
            throw new Exception('Erreur tri des attributions');

        return $this;
    }

    /**
     * renvoie la liste des persos prioritaires sur cet objet
     * @param int $limit limite de persos à renvoyer
     */
    public function getListeAttributions()
    {
        if($this->listeAttributions === false)
            throw new Exception('Attributions possibles non chargées');

        if(empty($this->listeAttributions))

            return array();

        return $this->listeAttributions;
    }

    /**
     * renvoie la liste des persos par ordre de priorité en json
     * @return string
     * @uses getlisteAttributions()
     */
    public function getListeAttributionsJson()
    {
        $listePersos = $this->getListeAttributions();
        if(empty($listePersos))

            return '[]';

        $return = array();
        foreach($listePersos as $perso)
            $return[] = $perso->getIdPerso();

        return json_encode($return);
    }

    /** nombre d'attribution de cet objet */
    protected $nbAttributions = 0;

    /**
     * renvoei le nombre d'attributions de cet objet
     * @return int
     */
    public function getNbAttributions()
    {
        return $this->nbAttributions;
    }

    //---------------------------------------------------------------
    // fonctions sur les tokens
    //---------------------------------------------------------------

    /**
     * teste si l'objet est un token
     * @return bool
     */
    public function isToken()
    {
        return SourceObjetQuery::create()
            ->filterByCode('token')
            ->filterByIdType($this->getIdObjet())
            ->count() > 0;
    }

    /**
     * renvoie les objets générés par celui ci
     * @return array
     */
    public function getGenerated()
    {
        return array_merge(array($this), ObjetQuery::create()
            ->useSourceObjetQuery()
                ->filterByCode('token')
                ->filterByIdType($this->getIdObjet())
            ->endUse()
            ->find()
            ->getData()
        );
    }

    //---------------------------------------------------------------
    // gestion des images
    //---------------------------------------------------------------

    /**
     * surcharge pour appeler l'importation
     * @return string
     * @uses importImage()
     */
    public function getImage($ext = '.jpg')
    {
        $this->importImage();
        $image = parent::getImage();

        return preg_match('/.+\.(jpg|png)$/', $image) ? $image : $image.$ext;
    }


    /**
     * renvoie le chemin physique du dossier dans lequel importer
     * les images
     * @return string
     */
    protected function getImgDir()
    {
        return dirname(__FILE__).'/../../web/images/items/';
    }

    /**
     * renvoie le chemin de l'image de l'objet
     * @return string
     * @uses getImgDir()
     */
    protected function getImgPath()
    {
        return sprintf('%s%s.jpg',
            $this->getImgDir(),
            $this->image
        );
    }

    /**
     * teste si l'objet a une image ou non
     * @return bool
     */
    protected function hasImage()
    {
        if($this->isNew())

            return true;

        return is_file(
            $this->getImgPath()
        );
    }

    /**
     * importe l'image de l'objet
     * @param bool $force flag à activer pour forcer l'import
     * @uses getImgPath()
     */
    protected function importImage($force = false)
    {
        if($this->hasImage() && !$force)

            return;

        $img = file_get_contents('http://wow.zamimg.com/images/wow/icons/medium/'.strtolower($this->image).'.jpg');
        if(!$img)
            throw new Exception(sprintf('Erreur importation "%s" depuis "http://wow.zamimg.com/images/wow/icons/medium/%s.jpg"',
                $this->getNomFr(), $this->image
            ));

        if(!file_put_contents($this->getImgPath(), $img))
            throw new Exception('Erreur écriture image');
    }

    /**
     * renvoie le tooltip wowhead de l'objet
     * @return string
     */
    public function getTooltip()
    {
        if(empty($this->id_objet))

            return '';

        return sprintf('item=%s&amp;domain=fr',
            $this->getIdObjet()
        );
    }

    //---------------------------------------------------------------
    // sauvegarde
    //---------------------------------------------------------------

    /**
     * surcharge du save pour récup les traductions des objets
     * @param PropelPDO $con
     */
    public function save(PropelPDO $con = null)
    {
        if(empty($this->nom_en) || !strlen(trim($this->nom_en)))
            $this->setNomEn(
                $this->importTraduction('www')
            );

        return parent::save($con);
    }

    /**
     * fonction d'import des noms d'objets
     * @param string lng
     */
    protected function importTraduction($lng)
    {
        $pageWowhead = file_get_contents(
            'http://'.$lng.'.wowhead.com/item='.$this->getIdObjet()
        );

        if (preg_match('#<h1>(.+) - Objet - World of Warcraft</h1>#', $pageWowhead, $matches)) {
            return $matches[1];
        } elseif (preg_match('#<h1>([\w -_\']+) - Item - World of Warcraft</h1>#', $pageWowhead, $matches)) {
            return $matches[1];
        }

        return null;
    }

} // Objet
